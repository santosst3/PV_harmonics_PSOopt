import numpy as np
import pyswarms as ps
from pyswarms.utils.plotters import plot_cost_history  # ,\
#    plot_contour, plot_surface
import matplotlib.pyplot as plt
import subprocess


def sphere_mod_simulink(x):
    """Sphere objective function.

    Has a global minimum at :code:`0` and with a search domain of
        :code:`[-inf, inf]`

    Parameters
    ----------
    x : numpy.ndarray
        set of inputs of shape :code:`(n_particles, dimensions)`

    Returns
    -------
    numpy.ndarray
        computed cost of size :code:`(n_particles, )`
    """

    # Initialize j
    j = np.ndarray(shape=(len(x), 1), dtype=float)

    # Remove old outputs.csv and create a fresh one
    subprocess.run('rm outputs.csv', shell=True, check=True)
    subprocess.run('touch outputs.csv', shell=True, check=True)

    # For each particle in x
    for k in range(0, len(x), 1):
        # writing particle x to file smc_param.m
        with open('smc_param.m', 'w', encoding='utf-8') as f:
            f.write('tr_L=' + repr(x[k, 0]) + ';\ntr_H='
                    + repr(x[k, 1]) + ';\nksmc='
                    + repr(x[k, 2]) + ';\n')
        # Run MATLAB script
        subprocess.run('matlab -nodisplay -batch "run_simulink"',
                       shell=True, check=True)
        # Reading file outputs.csv is outside the for loop

    # Read file outputs.csv generated by MATLAB script
    thd_str = np.genfromtxt('outputs.csv', delimiter=',')
    # Compute cost
    j = (thd_str ** 2.0).sum(axis=1)

    return j


# Set-up optimizer
options = {'c1': 0.5, 'c2': 0.5, 'w': 0.75}
optimizer = ps.single.GlobalBestPSO(n_particles=50, dimensions=3,
                                    options=options)
optimizer.optimize(sphere_mod_simulink, iters=50)
# Plot the cost
plot_cost_history(optimizer.cost_history)
plt.show()
